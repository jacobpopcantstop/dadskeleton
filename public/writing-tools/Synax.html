<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Synax | Creative Engine</title>
    
    <!-- Dad Skeleton Theme Favicon -->
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%23fd19c8' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><circle cx='12' cy='12' r='3'/><path d='M12 12 L6 6'/><path d='M12 12 L18 6'/><path d='M12 12 L12 20'/><circle cx='6' cy='6' r='1.5' fill='%23fd19c8' stroke='none'/><circle cx='18' cy='6' r='1.5' fill='%23fd19c8' stroke='none'/><circle cx='12' cy='20' r='1.5' fill='%23fd19c8' stroke='none'/></svg>">
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- Custom Config for Tailwind -->
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    fontFamily: {
                        serif: ['Georgia', 'Cambria', "Times New Roman", 'Times', 'serif'],
                        sans: ['Inter', 'system-ui', 'sans-serif'],
                    }
                }
            }
        }
    </script>
    
    <style>
        /* Custom Scrollbar Styles - Dad Skeleton Theme */
        .custom-scrollbar::-webkit-scrollbar {
            width: 6px;
        }
        .custom-scrollbar::-webkit-scrollbar-track {
            background: transparent;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb {
            background-color: rgba(253, 25, 200, 0.3);
            border-radius: 20px;
        }
        .dark .custom-scrollbar::-webkit-scrollbar-thumb {
            background-color: rgba(253, 25, 200, 0.4);
        }
        .no-scrollbar::-webkit-scrollbar {
            display: none;
        }
        .no-scrollbar {
            -ms-overflow-style: none;
            scrollbar-width: none;
        }
        
        /* Animation Utilities */
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        .animate-in {
            animation: fadeIn 0.3s ease-out forwards;
        }
    </style>
</head>
<body class="bg-[#000000] text-white dark:bg-[#000000] dark:text-white transition-colors duration-700">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;

        /* --- ICON SYSTEM --- */
        const Icon = ({ path, size = 24, className = "", ...props }) => (
            <svg 
                xmlns="http://www.w3.org/2000/svg" 
                width={size} 
                height={size} 
                viewBox="0 0 24 24" 
                fill="none" 
                stroke="currentColor" 
                strokeWidth="2" 
                strokeLinecap="round" 
                strokeLinejoin="round" 
                className={className}
                {...props}
            >
                <g dangerouslySetInnerHTML={{__html: path}} />
            </svg>
        );

        const ICONS = {
            Sparkles: '<path d="m12 3-1.912 5.813a2 2 0 0 1-1.275 1.275L3 12l5.813 1.912a2 2 0 0 1 1.275 1.275L12 21l1.912-5.813a2 2 0 0 1 1.275-1.275L12 3Z"/>',
            Feather: '<path d="M20.24 12.24a6 6 0 0 0-8.49-8.49L5 10.5V19h8.5z"/><line x1="16" y1="8" x2="2" y2="22"/><line x1="17.5" y1="15" x2="9" y2="15"/>',
            BookOpen: '<path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"/><path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"/>',
            Trash2: '<path d="M3 6h18"/><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"/><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"/><line x1="10" y1="11" x2="10" y2="17"/><line x1="14" y1="11" x2="14" y2="17"/>',
            RefreshCw: '<path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8"/><path d="M21 3v5h-5"/><path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16"/><path d="M8 16H3v5"/>',
            Grid: '<rect width="7" height="7" x="3" y="3" rx="1"/><rect width="7" height="7" x="14" y="3" rx="1"/><rect width="7" height="7" x="14" y="14" rx="1"/><rect width="7" height="7" x="3" y="14" rx="1"/>',
            Zap: '<polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"/>',
            Layers: '<polygon points="12 2 2 7 12 12 22 7 12 2"/><polyline points="2 17 12 22 22 17"/><polyline points="2 12 12 17 22 12"/>',
            Search: '<circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/>',
            Download: '<path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/>',
            X: '<path d="M18 6 6 18"/><path d="m6 6 12 12"/>',
            Type: '<polyline points="4 7 4 4 20 4 20 7"/><line x1="9" y1="20" x2="15" y2="20"/><line x1="12" y1="4" x2="12" y2="20"/>',
            Maximize2: '<polyline points="15 3 21 3 21 9"/><polyline points="9 21 3 21 3 15"/><line x1="21" y1="3" x2="14" y2="10"/><line x1="3" y1="21" x2="10" y2="14"/>',
            ChevronRight: '<path d="m9 18 6-6-6-6"/>',
            Settings: '<path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.74v-.47a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"/><circle cx="12" cy="12" r="3"/>',
            Mic: '<path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><line x1="12" y1="19" x2="12" y2="23"/><line x1="8" y1="23" x2="16" y2="23"/>',
            History: '<path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/><path d="M12 7v5l4 2"/>',
            Undo2: '<path d="M9 14 4 9l5-5"/><path d="M4 9h10.5a5.5 5.5 0 0 1 5.5 5.5v0a5.5 5.5 0 0 1-5.5 5.5H11"/>',
            Wifi: '<path d="M5 12.55a11 11 0 0 1 14.08 0"/><path d="M1.42 9a16 16 0 0 1 21.16 0"/><path d="M8.53 16.11a6 6 0 0 1 6.95 0"/><line x1="12" y1="20" x2="12.01" y2="20"/>',
            WifiOff: '<line x1="1" y1="1" x2="23" y2="23"/><path d="M16.72 11.06A10.94 10.94 0 0 1 19 12.55"/><path d="M5 12.55a10.94 10.94 0 0 1 5.17-2.39"/><path d="M10.71 5.05A16 16 0 0 1 22.58 9"/><path d="M1.42 9a15.91 15.91 0 0 1 4.7-2.88"/><path d="M8.53 16.11a6 6 0 0 1 6.95 0"/><line x1="12" y1="20" x2="12.01" y2="20"/>',
            Flame: '<path d="M8.5 14.5A2.5 2.5 0 0 0 11 12c0-1.38-.5-2-1-3-1.072-2.143-.224-4.054 2-6 .5 2.5 2 4.9 4 6.5 2 1.6 3 3.5 3 5.5a7 7 0 1 1-14 0c0-1.153.433-2.294 1-3a2.5 2.5 0 0 0 2.5 2.5z"/>',
            Synapse: '<circle cx="12" cy="12" r="3" /><path d="M12 12 L6 6" /><circle cx="6" cy="6" r="2" /><path d="M12 12 L18 6" /><circle cx="18" cy="6" r="2" /><path d="M12 12 L12 20" /><circle cx="12" cy="20" r="2" />',
            Timer: '<line x1="10" y1="2" x2="14" y2="2"/><line x1="12" y1="14" x2="15.5" y2="10.5"/><path d="M20.4 14.5a9 9 0 1 0-3.2 5.5"/><path d="M3.4 19.5 5 18"/>',
            Monitor: '<rect width="20" height="14" x="2" y="3" rx="2"/><line x1="8" y1="21" x2="16" y2="21"/><line x1="12" y1="17" x2="12" y2="21"/>',
            Layout: '<rect width="18" height="18" x="3" y="3" rx="2" ry="2"/><line x1="3" y1="9" x2="21" y2="9"/><line x1="9" y1="21" x2="9" y2="9"/>',
            Plus: '<line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/>',
            Minus: '<line x1="5" y1="12" x2="19" y2="12"/>'
        };

        const Sparkles = (props) => <Icon path={ICONS.Sparkles} {...props} />;
        const Feather = (props) => <Icon path={ICONS.Feather} {...props} />;
        const BookOpen = (props) => <Icon path={ICONS.BookOpen} {...props} />;
        const Trash2 = (props) => <Icon path={ICONS.Trash2} {...props} />;
        const RefreshCw = (props) => <Icon path={ICONS.RefreshCw} {...props} />;
        const Grid = (props) => <Icon path={ICONS.Grid} {...props} />;
        const Zap = (props) => <Icon path={ICONS.Zap} {...props} />;
        const Layers = (props) => <Icon path={ICONS.Layers} {...props} />;
        const Search = (props) => <Icon path={ICONS.Search} {...props} />;
        const Download = (props) => <Icon path={ICONS.Download} {...props} />;
        const X = (props) => <Icon path={ICONS.X} {...props} />;
        const Type = (props) => <Icon path={ICONS.Type} {...props} />;
        const Maximize2 = (props) => <Icon path={ICONS.Maximize2} {...props} />;
        const ChevronRight = (props) => <Icon path={ICONS.ChevronRight} {...props} />;
        const Settings = (props) => <Icon path={ICONS.Settings} {...props} />;
        const Mic = (props) => <Icon path={ICONS.Mic} {...props} />;
        const History = (props) => <Icon path={ICONS.History} {...props} />;
        const Undo2 = (props) => <Icon path={ICONS.Undo2} {...props} />;
        const Wifi = (props) => <Icon path={ICONS.Wifi} {...props} />;
        const WifiOff = (props) => <Icon path={ICONS.WifiOff} {...props} />;
        const Flame = (props) => <Icon path={ICONS.Flame} {...props} />;
        const Synapse = (props) => <Icon path={ICONS.Synapse} {...props} />;
        const Timer = (props) => <Icon path={ICONS.Timer} {...props} />;
        const Monitor = (props) => <Icon path={ICONS.Monitor} {...props} />;
        const Layout = (props) => <Icon path={ICONS.Layout} {...props} />;
        const Plus = (props) => <Icon path={ICONS.Plus} {...props} />;
        const Minus = (props) => <Icon path={ICONS.Minus} {...props} />;

        /* --- DATA LIBRARY --- */
        const LOCAL_LIBRARY = {
            nouns: [
                "abyss", "anomaly", "archetype", "automaton", "bastion", "behemoth", "catalyst", "chasm", "citadel", "conduit",
                "covenant", "cipher", "dynamo", "echo", "eclipse", "effigy", "enigma", "epoch", "expanse", "fragment",
                "fugitive", "glitch", "harbinger", "heirloom", "heretic", "horizon", "illusion", "inferno", "labyrinth", "legacy",
                "leviathan", "monolith", "monument", "mosaic", "myriad", "nebula", "nexus", "obelisk", "oracle", "paradox",
                "pariah", "phantom", "phenomenon", "pioneer", "prism", "prophecy", "relic", "remnant", "reverie", "sanctuary",
                "savant", "scion", "sentinel", "shadow", "silhouette", "specter", "spire", "summit", "syndicate", "talisman",
                "tempest", "titan", "totem", "vanguard", "velocity", "verdict", "vessel", "void", "vortex", "wraith", "zenith"
            ],
            verbs: [
                "accelerate", "amplify", "ascend", "assemble", "awaken", "banish", "beckon", "breach", "calibrate", "cascade",
                "catalyze", "channel", "clash", "collapse", "command", "compel", "conjure", "consume", "converge", "corrupt",
                "craft", "crumble", "decipher", "defy", "descend", "devour", "dismantle", "disrupt", "distort", "eclipse",
                "emerge", "engulf", "entangle", "erupt", "evolve", "exhale", "expand", "exploit", "extinguish", "fabricate",
                "falter", "fluctuate", "forge", "fracture", "fuse", "galvanize", "glimmer", "gravitate", "harness", "haunt",
                "ignite", "illuminate", "implode", "improvise", "infiltrate", "infuse", "invoke", "isolate", "kindle", "linger",
                "manifest", "mend", "mimic", "morph", "mutate", "navigate", "obliterate", "obscure", "orbit", "oscillate",
                "permeate", "pierce", "plummet", "precede", "provoke", "pulsate", "radiate", "ravage", "reclaim", "reconstruct"
            ],
            adjectives: [
                "absolute", "abstract", "abyssal", "ancient", "arcane", "artificial", "astral", "barren", "bioluminescent", "boundless",
                "brittle", "celestial", "chaotic", "chronological", "clandestine", "cognitive", "colossal", "corrosive", "cryptic", "crystalline",
                "cybernetic", "desolate", "digital", "divine", "dormant", "eldritch", "elusive", "empyrean", "endless", "ephemeral",
                "ethereal", "feral", "forbidden", "fractured", "frenetic", "frozen", "hollow", "holographic", "immortal", "imperceptible",
                "infinite", "intangible", "kinetic", "liminal", "lucid", "luminous", "malevolent", "mechanical", "merciless", "molten",
                "nebulous", "obsidian", "ominous", "opalescent", "perpetual", "primal", "prismatic", "profound", "quantum", "radiant",
                "relentless", "resonant", "savage", "sentient", "shattered", "silent", "solar", "spectral", "static", "sublime"
            ],
            actors: [
                "The Alchemist", "The Architect", "The Automaton", "The Bard", "The Catalyst", "The Diplomat", "The Drifter", 
                "The Exile", "The Forger", "The Guardian", "The Harbinger", "The Healer", "The Heretic", "The Hunter", 
                "The Illusionist", "The Inventor", "The Judge", "The Keeper", "The Mercenary", "The Monk", "The Mystic", 
                "The Navigator", "The Nomad", "The Oracle", "The Outlaw", "The Paladin", "The Phantom", "The Philosopher", 
                "The Pioneer", "The Prophet", "The Rebel", "The Rogue", "The Sage", "The Savant", "The Scavenger", "The Scholar", 
                "The Scout", "The Sentinel", "The Shaman", "The Shepherd", "The Soldier", "The Specter", "The Spy", "The Strategist", 
                "The Survivor", "The Tactician", "The Technician", "The Thief", "The Titan", "The Traveler", "The Vanguard", 
                "The Veteran", "The Visionary", "The Wanderer", "The Warden", "The Warlock", "The Warrior", "The Weaver", 
                "The Whisperer", "The Witness", "The Wraith", "The Zealot"
            ],
            settings: [
                "Abandoned Station", "Ancient Ruins", "Astral Plane", "Bustling Market", "Celestial Observatory", "Chrome Citadel", 
                "Clockwork Tower", "Crystal Cavern", "Cyber Slums", "Dark Forest", "Desolate Wasteland", "Digital Void", 
                "Distant Moon", "Drowned City", "Echoing Canyon", "Floating Island", "Foggy Harbor", "Forbidden Library", 
                "Forgotten Temple", "Frozen Tundra", "Glass Spire", "Hidden Sanctuary", "High Council", "Hollow Earth", 
                "Infinite Corridor", "Iron Fortress", "Ivory Tower", "Lost Colony", "Luminous Grove", "Magnetic Fields", 
                "Marble Hall", "Midnight Garden", "Misty Moor", "Neon Metropolis", "Obsidian Spire", "Ocean Floor", "Orbital Ring", 
                "Parallel Dimension", "Quantum Realm", "Quiet Village", "Radioactive Zone", "Sacred Grove", "Secret Laboratory", 
                "Shifting Sands", "Silent Monastery", "Sky Fortress", "Smoky Tavern", "Solar Array", "Starlit Void", 
                "Steam Tunnels", "Stone Circle", "Stormy Coast", "Subterranean City", "Sunken Ship", "Temporal Rift", 
                "Throne Room", "Twilight Zone", "Underground Bunker", "Urban Decay", "Velvet Room", "Volcanic Crater", 
                "Whispering Woods", "Wind-Swept Plains"
            ]
        };

        const DATAMUSE_API = 'https://api.datamuse.com/words';
        const getRandom = (arr) => arr[Math.floor(Math.random() * arr.length)];

        /* --- APP COMPONENTS --- */

        const Card = ({ id, word, type, onPin, isPinned, onDefine, onSwap, onDelete }) => (
        <div className="group relative bg-white/80 dark:bg-slate-800/60 backdrop-blur-sm border border-violet-100 dark:border-white/5 rounded-2xl p-8 shadow-sm hover:shadow-2xl hover:shadow-violet-500/10 hover:-translate-y-1 hover:border-violet-200 dark:hover:border-violet-500/30 transition-all duration-500 animate-in fade-in zoom-in-95 fill-mode-forwards">
            <div className="absolute top-4 right-4 flex gap-1 opacity-0 group-hover:opacity-100 transition-all duration-300 translate-y-2 group-hover:translate-y-0 bg-white/90 dark:bg-slate-800/90 rounded-lg p-1 shadow-sm backdrop-blur-sm border border-slate-100 dark:border-white/5">
                <button 
                    onClick={(e) => { e.stopPropagation(); onSwap(id, type); }} 
                    className="p-1.5 text-slate-400 hover:text-violet-600 hover:bg-violet-50 dark:hover:bg-violet-900/30 rounded-md transition-colors" 
                    title="Regenerate this word"
                >
                    <RefreshCw size={14} />
                </button>
                <button 
                    onClick={(e) => { e.stopPropagation(); onDelete(id); }} 
                    className="p-1.5 text-slate-400 hover:text-rose-500 hover:bg-rose-50 dark:hover:bg-rose-900/30 rounded-md transition-colors" 
                    title="Remove"
                >
                    <X size={14} />
                </button>
                <div className="w-px h-4 bg-slate-200 dark:bg-slate-700 mx-1 self-center"></div>
                <button 
                    onClick={(e) => { e.stopPropagation(); onDefine(word); }} 
                    className="p-1.5 text-slate-400 hover:text-violet-600 hover:bg-violet-50 dark:hover:bg-violet-900/30 rounded-md transition-colors" 
                    title="Define"
                >
                    <BookOpen size={14} />
                </button>
                <button 
                    onClick={(e) => { e.stopPropagation(); onPin(word, type); }} 
                    className={`p-1.5 rounded-md transition-colors ${isPinned ? 'text-violet-600 bg-violet-100 dark:bg-violet-900/50' : 'text-slate-400 hover:text-violet-600 hover:bg-violet-50 dark:hover:bg-violet-900/30'}`} 
                    title="Pin"
                >
                    <Sparkles size={14} className={isPinned ? "fill-current" : ""} />
                </button>
            </div>
            <span className="inline-block px-2 py-1 rounded bg-slate-100 dark:bg-white/5 text-[10px] font-bold tracking-widest text-slate-500 dark:text-slate-400 uppercase mb-4 border border-transparent group-hover:border-violet-100 dark:group-hover:border-violet-500/20 transition-colors">
            {type}
            </span>
            <h3 className="text-3xl md:text-4xl font-serif font-medium text-slate-800 dark:text-slate-100 tracking-tight leading-tight group-hover:text-violet-900 dark:group-hover:text-white transition-colors">
            {word}
            </h3>
        </div>
        );

        const ModeSelector = ({ activeMode, setMode }) => {
            const modes = [
                { id: 'random', label: 'Serendipity', icon: Zap, desc: 'Curated discovery' },
                { id: 'triad', label: 'Narrative', icon: Layers, desc: 'Actor, Action, Setting' },
                { id: 'context', label: 'Context', icon: Grid, desc: 'Thematic associations' },
                { id: 'rhyme', label: 'Phonetics', icon: Mic, desc: 'Sonic connections' },
            ];

            return (
                <div className="flex gap-4 mb-4 overflow-x-auto p-4 no-scrollbar">
                {modes.map(m => (
                    <button
                    key={m.id}
                    onClick={() => setMode(m.id)}
                    className={`relative group flex-shrink-0 flex items-center gap-4 px-6 py-4 rounded-2xl border transition-all duration-300 ${
                        activeMode === m.id 
                        ? 'bg-violet-600 text-white border-transparent shadow-lg shadow-violet-600/20 scale-105' 
                        : 'bg-white dark:bg-slate-800/40 text-slate-600 dark:text-slate-400 border-slate-200 dark:border-white/5 hover:border-violet-200 dark:hover:border-violet-500/30 hover:bg-violet-50/50 dark:hover:bg-violet-900/10'
                    }`}
                    >
                    <div className={`p-2 rounded-lg ${activeMode === m.id ? 'bg-white/20' : 'bg-slate-100 dark:bg-white/5 group-hover:bg-violet-100 dark:group-hover:bg-violet-500/20'} transition-colors`}>
                        <m.icon size={20} />
                    </div>
                    <div className="text-left">
                        <div className="font-bold text-sm tracking-wide">{m.label}</div>
                        <div className={`text-[10px] font-medium ${activeMode === m.id ? 'text-violet-100' : 'text-slate-400'}`}>{m.desc}</div>
                    </div>
                    </button>
                ))}
                </div>
            );
        };

        function Synax() {
            // --- STATE ---
            const [words, setWords] = useState([]);
            const [mode, setMode] = useState('random'); 
            const [loading, setLoading] = useState(false);
            const [contextInput, setContextInput] = useState('');
            const [definition, setDefinition] = useState(null);
            const [showCanvas, setShowCanvas] = useState(false);
            const [showSettings, setShowSettings] = useState(false);
            const [serendipityCount, setSerendipityCount] = useState(4);
            
            // Persistent State
            const [pinned, setPinned] = useState(() => {
                try {
                    const saved = localStorage.getItem('writingtools_synax_pinned');
                    return saved ? JSON.parse(saved) : [];
                } catch { return []; }
            });
            const [editorContent, setEditorContent] = useState(() => {
                return localStorage.getItem('writingtools_synax_editor') || '';
            });
            const [history, setHistory] = useState([]);
            
            // Settings State
            const [offlineMode, setOfflineMode] = useState(false);
            const [darkMode, setDarkMode] = useState(true);
            const [minimalMode, setMinimalMode] = useState(false);
            const [autoGen, setAutoGen] = useState(false);
            const [autoGenInterval, setAutoGenInterval] = useState(5);

            // Word repetition prevention - tracks recently used words
            const [recentWords, setRecentWords] = useState([]);
            const REPETITION_COOLDOWN = 10; // Number of generations before a word can be reused

            // Refs
            const textareaRef = useRef(null);

            // --- EFFECTS ---

            useEffect(() => {
                localStorage.setItem('writingtools_synax_pinned', JSON.stringify(pinned));
            }, [pinned]);

            useEffect(() => {
                localStorage.setItem('writingtools_synax_editor', editorContent);
            }, [editorContent]);

            useEffect(() => {
                if (darkMode) document.documentElement.classList.add('dark');
                else document.documentElement.classList.remove('dark');
            }, [darkMode]);

            // Initial Load
            useEffect(() => {
                if (words.length === 0) generate();
            }, []);

            // Keyboard shortcuts
            useEffect(() => {
                const handleKeyPress = (e) => {
                // Space to generate (when not typing)
                if (e.code === 'Space' && e.target.tagName !== 'INPUT' && e.target.tagName !== 'TEXTAREA') {
                    e.preventDefault();
                    generate();
                }
                // Escape to close canvas
                if (e.code === 'Escape' && showCanvas) {
                    setShowCanvas(false);
                }
                };
                window.addEventListener('keydown', handleKeyPress);
                return () => window.removeEventListener('keydown', handleKeyPress);
            }, [mode, contextInput, offlineMode, serendipityCount, showCanvas]);

            // --- LOGIC ---

            const insertAtCursor = (textToInsert) => {
                if (!textareaRef.current) return;
                
                const textarea = textareaRef.current;
                const start = textarea.selectionStart;
                const end = textarea.selectionEnd;
                const text = textarea.value;
                
                const newText = text.substring(0, start) + textToInsert + text.substring(end);
                setEditorContent(newText);
                
                setTimeout(() => {
                textarea.focus();
                textarea.setSelectionRange(start + textToInsert.length, start + textToInsert.length);
                }, 0);
            };

            const fetchDatamuse = async (params) => {
                if (offlineMode) throw new Error("Offline Mode Enforced");
                const query = new URLSearchParams(params).toString();
                const res = await fetch(`${DATAMUSE_API}?${query}&max=40`);
                if (!res.ok) throw new Error('API Error');
                const data = await res.json();
                return data.map(d => d.word);
            };

            const addToHistory = (newSet) => {
                setHistory(prev => [...prev.slice(-9), newSet]);
                setWords(newSet);
                // Add words to recent list for repetition prevention
                const newWordTexts = newSet.map(w => w.word.toLowerCase());
                setRecentWords(prev => [...prev, ...newWordTexts].slice(-REPETITION_COOLDOWN * 4));
            };

            // Get random word with repetition prevention
            const getRandomAvoidRecent = (arr) => {
                // Filter out recently used words
                const available = arr.filter(w => !recentWords.includes(w.toLowerCase()));
                // If too few available, use full array
                if (available.length < 5) return getRandom(arr);
                return getRandom(available);
            };

            const undoGeneration = () => {
                if (history.length > 1) {
                const newHistory = [...history];
                newHistory.pop();
                const previous = newHistory[newHistory.length - 1];
                setHistory(newHistory);
                setWords(previous);
                }
            };

            const handleSwap = (id, type) => {
                let newWord = "";

                // Helper to get random word by type with repetition prevention
                if (type.includes('Noun')) newWord = getRandomAvoidRecent(LOCAL_LIBRARY.nouns);
                else if (type.includes('Verb')) newWord = getRandomAvoidRecent(LOCAL_LIBRARY.verbs);
                else if (type.includes('Adjective')) newWord = getRandomAvoidRecent(LOCAL_LIBRARY.adjectives);
                else if (type.includes('Actor')) newWord = getRandomAvoidRecent(LOCAL_LIBRARY.actors);
                else if (type.includes('Setting')) newWord = getRandomAvoidRecent(LOCAL_LIBRARY.settings);
                else newWord = getRandomAvoidRecent(LOCAL_LIBRARY.nouns); // Fallback for wildcards/other

                // Track this swapped word to prevent immediate repetition
                setRecentWords(prev => [...prev, newWord.toLowerCase()].slice(-REPETITION_COOLDOWN * 4));

                setWords(prevWords => prevWords.map(w =>
                    w.id === id ? { ...w, word: newWord } : w
                ));
            };

            const handleDelete = (id) => {
                setWords(prevWords => prevWords.filter(w => w.id !== id));
            };

            const generate = useCallback(async () => {
                setLoading(true);
                let newWords = [];

                try {
                if (mode === 'random') {
                    const definitions = [
                        { type: 'Noun', src: LOCAL_LIBRARY.nouns },
                        { type: 'Verb', src: LOCAL_LIBRARY.verbs },
                        { type: 'Adjective', src: LOCAL_LIBRARY.adjectives }
                    ];

                    for (let i = 0; i < serendipityCount; i++) {
                        let type, word;
                        // Cycle through base types first, then random/wildcard
                        if (i < 3) {
                            type = definitions[i].type;
                            word = getRandomAvoidRecent(definitions[i].src);
                        } else {
                            // Logic for extra words: mostly nouns or actors for variety
                            const roll = Math.random();
                            if (roll < 0.3) {
                                type = 'Actor';
                                word = getRandomAvoidRecent(LOCAL_LIBRARY.actors);
                            } else if (roll < 0.6) {
                                type = 'Adjective';
                                word = getRandomAvoidRecent(LOCAL_LIBRARY.adjectives);
                            } else {
                                type = 'Wildcard';
                                word = getRandomAvoidRecent(LOCAL_LIBRARY.nouns);
                            }
                        }
                        newWords.push({ word, type });
                    }
                } else if (mode === 'triad') {
                    let actor, action, setting;
                    if (offlineMode) {
                    actor = getRandomAvoidRecent(LOCAL_LIBRARY.actors);
                    action = getRandomAvoidRecent(LOCAL_LIBRARY.verbs);
                    setting = getRandomAvoidRecent(LOCAL_LIBRARY.settings);
                    } else {
                    try {
                        const actors = await fetchDatamuse({ ml: 'character', max: 50 });
                        actor = getRandomAvoidRecent(actors) || getRandomAvoidRecent(LOCAL_LIBRARY.actors);
                        const settings = await fetchDatamuse({ ml: 'place', max: 50 });
                        setting = getRandomAvoidRecent(settings) || getRandomAvoidRecent(LOCAL_LIBRARY.settings);
                        action = getRandomAvoidRecent(LOCAL_LIBRARY.verbs);
                    } catch (e) {
                        actor = getRandomAvoidRecent(LOCAL_LIBRARY.actors);
                        action = getRandomAvoidRecent(LOCAL_LIBRARY.verbs);
                        setting = getRandomAvoidRecent(LOCAL_LIBRARY.settings);
                    }
                    }
                    newWords = [
                    { word: actor, type: 'The Actor' },
                    { word: action, type: 'The Action' },
                    { word: setting, type: 'The Setting' }
                    ];
                } else if (mode === 'context') {
                    if (!contextInput) {
                        const concepts = ["Time", "Space", "War", "Love", "Fear", "Nature"];
                        const seed = getRandom(concepts);
                        setContextInput(seed); 
                    }
                    
                    if (offlineMode) {
                        newWords = [
                        { word: getRandom(LOCAL_LIBRARY.nouns), type: 'Concept (Offline)' },
                        { word: getRandom(LOCAL_LIBRARY.adjectives), type: 'Concept (Offline)' },
                        { word: getRandom(LOCAL_LIBRARY.verbs), type: 'Concept (Offline)' },
                        { word: getRandom(LOCAL_LIBRARY.settings), type: 'Concept (Offline)' }
                        ];
                    } else {
                        const effectiveInput = contextInput || getRandom(["Time", "Space", "War", "Love", "Fear", "Nature"]);
                        
                        const adj = await fetchDatamuse({ rel_jjb: effectiveInput, max: 15 });
                        const nouns = await fetchDatamuse({ ml: effectiveInput, max: 15 });
                        const triggers = await fetchDatamuse({ rel_trg: effectiveInput, max: 15 });
            
                        const pool = [
                        ...adj.map(w => ({ word: w, type: 'Descriptor' })),
                        ...nouns.map(w => ({ word: w, type: 'Related' })),
                        ...triggers.map(w => ({ word: w, type: 'Association' }))
                        ];
                        newWords = pool.sort(() => 0.5 - Math.random()).slice(0, 6);
                        if (newWords.length < 3) throw new Error("Not enough words");
                    }
                } else if (mode === 'rhyme') {
                    if (!contextInput) {
                        setLoading(false);
                        return;
                    }
                    if (offlineMode) {
                        alert("Rhyme mode requires internet connection.");
                        setLoading(false);
                        return;
                    }
                    const perfect = await fetchDatamuse({ rel_rhy: contextInput, max: 20 });
                    const slant = await fetchDatamuse({ rel_nry: contextInput, max: 20 });
                    const pool = [
                    ...perfect.map(w => ({ word: w, type: 'Perfect Rhyme' })),
                    ...slant.map(w => ({ word: w, type: 'Near Rhyme' }))
                    ];
                    newWords = pool.sort(() => 0.5 - Math.random()).slice(0, 8);
                }
                } catch (err) {
                newWords = [
                    { word: getRandomAvoidRecent(LOCAL_LIBRARY.nouns), type: 'Noun (Offline)' },
                    { word: getRandomAvoidRecent(LOCAL_LIBRARY.verbs), type: 'Verb (Offline)' },
                    { word: getRandomAvoidRecent(LOCAL_LIBRARY.adjectives), type: 'Adjective (Offline)' },
                    { word: getRandomAvoidRecent(LOCAL_LIBRARY.nouns), type: 'Noun (Offline)' }
                ];
                }
                const finalSet = newWords.map((w, i) => ({ ...w, id: Date.now() + i }));
                addToHistory(finalSet);
                setLoading(false);
            }, [mode, contextInput, offlineMode, serendipityCount]); 

            // Auto-Generate Effect
            useEffect(() => {
                let interval;
                if (autoGen) {
                    interval = setInterval(() => {
                        if (!loading) {
                            generate();
                        }
                    }, autoGenInterval * 1000);
                }
                return () => clearInterval(interval);
            }, [autoGen, autoGenInterval, generate, loading]);

            const generateSpark = () => {
                const adj = getRandomAvoidRecent(LOCAL_LIBRARY.adjectives);
                const actor = getRandomAvoidRecent(LOCAL_LIBRARY.actors);
                const verb = getRandomAvoidRecent(LOCAL_LIBRARY.verbs);
                const setting = getRandomAvoidRecent(LOCAL_LIBRARY.settings);
                const sentence = `The ${adj} ${actor} ${verb}s in the ${setting}.`;
                // Track these words
                setRecentWords(prev => [...prev, adj.toLowerCase(), actor.toLowerCase(), verb.toLowerCase(), setting.toLowerCase()].slice(-REPETITION_COOLDOWN * 4));
                setEditorContent(prev => prev + (prev ? '\n' : '') + sentence);
                setShowCanvas(true);
                setTimeout(() => {
                    if(textareaRef.current) {
                        textareaRef.current.scrollTop = textareaRef.current.scrollHeight;
                    }
                }, 100);
            };

            const handlePin = (word, type) => {
                if (!pinned.some(p => p.word === word)) {
                setPinned([...pinned, { word, type, id: Date.now() }]);
                } else {
                setPinned(pinned.filter(p => p.word !== word));
                }
            };

            const fetchDefinition = async (word) => {
                const cleanWord = word.replace(/^The\s+/i, '');
                setLoading(true);
                try {
                const res = await fetch(`https://api.dictionaryapi.dev/api/v2/entries/en/${cleanWord}`);
                const data = await res.json();
                if (data && data[0]) {
                    setDefinition(data[0]);
                } else {
                    setDefinition({ word: cleanWord, meanings: [] });
                }
                } catch (e) {
                setDefinition({ word: cleanWord, meanings: [] });
                }
                setLoading(false);
            };

            const clearHistory = () => {
                setHistory([]);
                setWords([]);
            };

            const clearCanvas = () => {
                if(window.confirm("Clear your writing canvas?")) {
                    setEditorContent('');
                }
            };

            return (
                <div className={`min-h-screen transition-colors duration-700 ease-in-out ${darkMode ? 'bg-[#0b0a14] text-slate-300' : 'bg-[#f5f3ff] text-slate-800'} font-sans overflow-hidden flex flex-col relative`}>
                
                {/* Background Ambience (Hidden in Minimal Mode) */}
                {!minimalMode && (
                    <div className={`absolute top-0 left-0 right-0 h-[500px] pointer-events-none opacity-40 transition-opacity duration-1000 ${darkMode ? 'opacity-30' : 'opacity-60'}`}>
                    <div className="absolute top-[-20%] right-[-10%] w-[600px] h-[600px] rounded-full bg-violet-600/20 blur-[100px]" />
                    <div className="absolute top-[10%] left-[-10%] w-[500px] h-[500px] rounded-full bg-fuchsia-500/20 blur-[120px]" />
                    </div>
                )}

                {/* --- HEADER --- */}
                {minimalMode ? (
                    <div className="absolute top-4 right-4 z-50">
                    <button 
                        onClick={() => setShowSettings(true)}
                        className="p-3 rounded-full bg-white/10 hover:bg-white/20 backdrop-blur-md text-slate-400 hover:text-white transition-colors shadow-lg"
                    >
                        <Settings size={20} />
                    </button>
                    </div>
                ) : (
                    <header className="flex-none px-6 py-4 border-b border-violet-100/50 dark:border-white/5 bg-white/40 dark:bg-[#0b0a14]/60 backdrop-blur-xl z-20 flex justify-between items-center sticky top-0">
                        <div className="flex items-center gap-3">
                        <div className="w-9 h-9 bg-gradient-to-br from-violet-600 to-fuchsia-600 rounded-xl flex items-center justify-center text-white shadow-lg shadow-violet-600/20 ring-1 ring-white/20">
                            <Synapse size={18} />
                        </div>
                        <div>
                            <h1 className="text-xl font-black tracking-tight text-slate-900 dark:text-white font-serif leading-none">Synax</h1>
                            <span className="text-[10px] font-bold tracking-widest text-violet-500 dark:text-violet-400 uppercase">Creative Engine v3.2</span>
                        </div>
                        </div>

                        <div className="flex items-center gap-3">
                        <button 
                            onClick={() => setShowCanvas(!showCanvas)}
                            className={`hidden md:flex items-center gap-2 text-sm font-bold px-4 py-2 rounded-full transition-all duration-300 ${showCanvas ? 'bg-violet-100 dark:bg-violet-900/30 text-violet-700 dark:text-violet-300 shadow-inner' : 'hover:bg-white/50 dark:hover:bg-white/5 text-slate-600 dark:text-slate-400'}`}
                        >
                            <Maximize2 size={16} /> {showCanvas ? 'Hide Canvas' : 'Canvas'}
                        </button>
                        <button 
                            onClick={() => setShowSettings(true)}
                            className="p-2.5 rounded-full hover:bg-white/50 dark:hover:bg-white/10 transition-colors text-slate-600 dark:text-slate-400"
                        >
                            <Settings size={20} />
                        </button>
                        </div>
                    </header>
                )}

                <div className="flex-1 flex overflow-hidden relative z-10">
                    
                    {/* --- MAIN GENERATOR AREA --- */}
                    <main className={`flex-1 flex flex-col p-4 md:p-8 transition-all duration-500 ease-in-out ${showCanvas && !minimalMode ? 'md:w-[calc(100%-400px)] lg:w-[calc(100%-480px)]' : 'w-full'}`}>
                    
                    <div className="max-w-5xl mx-auto w-full flex flex-col h-full">
                        
                        {/* Controls */}
                        {!minimalMode && (
                            <div className="flex-none mb-6">
                            <ModeSelector activeMode={mode} setMode={setMode} />
                            
                            {(mode === 'context' || mode === 'rhyme') && (
                                <div className="mb-6 animate-in slide-in-from-top-4 fade-in duration-300">
                                <div className="relative group">
                                    <Search className="absolute left-4 top-1/2 -translate-y-1/2 text-slate-400 group-focus-within:text-violet-500 transition-colors" size={20} />
                                    <input 
                                    type="text" 
                                    value={contextInput}
                                    onChange={(e) => setContextInput(e.target.value)}
                                    placeholder={mode === 'context' ? "Enter a topic (e.g., Space, Ocean)..." : "Enter a word to find rhymes..."}
                                    className="w-full bg-white/50 dark:bg-white/5 border border-violet-100 dark:border-white/10 rounded-2xl py-4 pl-12 pr-4 text-lg focus:outline-none focus:ring-2 focus:ring-violet-500/50 focus:border-violet-500 shadow-sm transition-all placeholder:text-slate-400 dark:placeholder:text-slate-600 text-slate-800 dark:text-slate-100"
                                    onKeyDown={(e) => e.key === 'Enter' && generate()}
                                    />
                                </div>
                                </div>
                            )}

                            {mode === 'random' && (
                                <div className="mb-6 animate-in slide-in-from-top-4 fade-in duration-300">
                                    <div className="flex items-center gap-4 bg-white/50 dark:bg-white/5 border border-violet-100 dark:border-white/10 rounded-2xl p-4">
                                         <div className="flex items-center gap-2 text-violet-600 dark:text-violet-400">
                                            <Layers size={18} />
                                            <span className="text-sm font-bold uppercase tracking-wider">Words: {serendipityCount}</span>
                                         </div>
                                         <div className="flex-1 flex items-center gap-4">
                                            <button onClick={() => setSerendipityCount(Math.max(1, serendipityCount - 1))} className="p-1 rounded-full hover:bg-black/5 dark:hover:bg-white/10"><Minus size={16} /></button>
                                            <input 
                                              type="range" 
                                              min="1" 
                                              max="12" 
                                              value={serendipityCount} 
                                              onChange={(e) => setSerendipityCount(parseInt(e.target.value))}
                                              className="flex-1 h-2 bg-slate-200 dark:bg-white/10 rounded-lg appearance-none cursor-pointer accent-violet-500"
                                            />
                                            <button onClick={() => setSerendipityCount(Math.min(12, serendipityCount + 1))} className="p-1 rounded-full hover:bg-black/5 dark:hover:bg-white/10"><Plus size={16} /></button>
                                         </div>
                                    </div>
                                </div>
                            )}
                            </div>
                        )}

                        {/* Action Bar */}
                        <div className={`flex-none flex flex-wrap items-center justify-center gap-3 mb-6 pb-6 border-b border-violet-100 dark:border-white/5 ${minimalMode ? 'pt-8' : ''}`}>
                            {history.length > 1 && (
                                <button 
                                    onClick={undoGeneration}
                                    className="px-4 py-3 rounded-xl border border-violet-100 dark:border-white/10 text-slate-500 hover:text-violet-600 dark:hover:text-white hover:bg-white dark:hover:bg-white/5 transition-colors flex items-center gap-2"
                                    title="Undo last generation"
                                >
                                    <Undo2 size={18} />
                                </button>
                            )}
                            
                            <button 
                                onClick={generate}
                                className="group relative flex-1 max-w-xs px-8 py-3 bg-gradient-to-r from-violet-600 to-fuchsia-600 hover:from-violet-500 hover:to-fuchsia-500 text-white rounded-xl font-bold shadow-lg shadow-violet-600/25 active:scale-95 transition-all flex items-center justify-center gap-2 overflow-hidden"
                            >
                                {autoGen ? (
                                    <div className="absolute inset-0 bg-white/10 flex items-center justify-center">
                                        <div className="w-full h-1 bg-white/30 absolute bottom-0 left-0">
                                            <div className="h-full bg-white animate-pulse" style={{ width: '100%' }} />
                                        </div>
                                    </div>
                                ) : (
                                    <div className="absolute inset-0 bg-white/20 translate-y-full group-hover:translate-y-0 transition-transform duration-300 rounded-xl" />
                                )}
                                
                                {autoGen ? (
                                    <span className="flex items-center gap-2 animate-pulse"><Timer size={18} /> Auto ({autoGenInterval}s)</span>
                                ) : (
                                    <>
                                        <RefreshCw size={20} className={loading ? "animate-spin" : "group-hover:rotate-180 transition-transform duration-500"} />
                                        <span className="relative">Generate</span>
                                    </>
                                )}
                            </button>

                            {!minimalMode && (
                                <button 
                                    onClick={generateSpark}
                                    className="px-6 py-3 rounded-xl border border-violet-200 dark:border-white/10 text-violet-600 dark:text-violet-300 hover:bg-violet-50 dark:hover:bg-violet-900/20 hover:border-violet-300 transition-colors flex items-center gap-2 font-bold"
                                    title="Generate a full sentence"
                                >
                                    <Flame size={18} className="fill-violet-200 dark:fill-violet-900/0" />
                                    Spark Idea
                                </button>
                            )}
                        </div>

                        {/* Output Grid */}
                        <div className="flex-1 overflow-y-auto min-h-[300px] mb-6 p-4 custom-scrollbar pb-20">
                        {loading ? (
                            <div className="h-full flex flex-col items-center justify-center opacity-70 space-y-6">
                            <div className="relative">
                                <div className="w-16 h-16 border-4 border-violet-500/30 border-t-violet-500 rounded-full animate-spin"></div>
                                <div className="absolute inset-0 flex items-center justify-center">
                                    <Sparkles size={20} className="text-violet-500 animate-pulse" />
                                </div>
                            </div>
                            <p className="font-mono text-xs tracking-[0.2em] uppercase text-violet-400 font-bold">Processing...</p>
                            </div>
                        ) : (
                            <div className="space-y-6">
                                <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4">
                                {words.map((w) => (
                                    <Card 
                                    key={w.id} 
                                    id={w.id}
                                    word={w.word} 
                                    type={w.type} 
                                    onPin={handlePin} 
                                    isPinned={pinned.some(p => p.word === w.word)}
                                    onDefine={fetchDefinition}
                                    onSwap={handleSwap}
                                    onDelete={handleDelete}
                                    />
                                ))}
                                </div>
                            </div>
                        )}
                        </div>

                        {/* Footer Status */}
                        {!minimalMode && (
                            <div className="absolute bottom-4 left-4 right-4 flex justify-between items-center text-[10px] font-bold tracking-widest text-slate-400 uppercase">
                            <span className="flex items-center gap-2 px-3 py-1 rounded-full bg-white/50 dark:bg-white/5 backdrop-blur-sm">
                                {offlineMode ? <WifiOff size={12} className="text-rose-400"/> : <Wifi size={12} className="text-emerald-400"/>}
                                {offlineMode ? 'OFFLINE' : 'ONLINE'}
                            </span>
                            <a href="index.html" className="opacity-30 hover:opacity-100 transition-opacity" style={{textDecoration: 'none', color: 'inherit'}}>Writing Tools Suite</a>
                            </div>
                        )}

                    </div>
                    </main>

                    {/* --- THE CANVAS (Writing Area) --- */}
                    {/* Hidden entirely in minimal mode */}
                    {!minimalMode && (
                        <aside className={`fixed inset-y-0 right-0 w-full md:w-[400px] lg:w-[480px] bg-white/90 dark:bg-[#12111a]/95 backdrop-blur-xl border-l border-violet-100 dark:border-white/5 shadow-2xl transform transition-transform duration-300 z-30 flex flex-col ${showCanvas ? 'translate-x-0' : 'translate-x-full'}`}>
                        
                        {/* Canvas Header */}
                        <div className="flex-none p-4 border-b border-violet-100 dark:border-white/5 flex justify-between items-center bg-violet-50/30 dark:bg-white/5">
                            <div className="flex items-center gap-2 text-violet-600 dark:text-violet-300 font-bold">
                            <Type size={18} />
                            <span>Canvas</span>
                            </div>
                            <button
                                onClick={() => setShowCanvas(false)}
                                className="flex items-center gap-2 px-3 py-1.5 rounded-lg bg-slate-100 dark:bg-white/10 hover:bg-rose-100 dark:hover:bg-rose-900/30 text-slate-500 hover:text-rose-600 transition-colors font-bold text-xs"
                            >
                                <X size={16}/>
                                <span>Close</span>
                            </button>
                        </div>

                        {/* Pinned Words (The Palette) */}
                        <div className="flex-none p-5 space-y-4 bg-gradient-to-b from-violet-50/50 to-transparent dark:from-white/5 dark:to-transparent">
                            <div className="flex justify-between items-center">
                                <h3 className="text-xs font-bold text-violet-400 uppercase tracking-widest flex items-center gap-2">
                                    <Synapse size={14}/> Pinned Concepts
                                </h3>
                                {pinned.length > 0 && (
                                    <button onClick={() => setPinned([])} className="text-[10px] text-rose-400 hover:text-rose-500 font-bold uppercase tracking-wider">Clear</button>
                                )}
                            </div>
                            
                            <div className="flex flex-wrap gap-2 max-h-[160px] overflow-y-auto custom-scrollbar p-1">
                            {pinned.length === 0 ? (
                                <div className="w-full text-center py-6 border-2 border-dashed border-violet-100 dark:border-white/5 rounded-xl">
                                    <Sparkles className="mx-auto text-violet-200 mb-2" size={20} />
                                    <p className="text-xs text-slate-400 font-medium">Pin words to save them</p>
                                </div>
                            ) : (
                                pinned.map(p => (
                                <div 
                                    key={p.id} 
                                    className="group flex items-center gap-0 bg-white dark:bg-[#1a1924] border border-violet-100 dark:border-white/10 rounded-full shadow-sm hover:shadow-md transition-all duration-200 animate-in zoom-in"
                                >
                                    <span 
                                        onClick={() => insertAtCursor(' ' + p.word)}
                                        className="px-3 py-1.5 text-sm font-medium text-slate-600 dark:text-slate-200 cursor-pointer hover:text-violet-600 dark:hover:text-violet-300 transition-colors border-r border-violet-50 dark:border-white/5"
                                    >
                                    {p.word}
                                    </span>
                                    <button 
                                    onClick={(e) => { e.stopPropagation(); setPinned(pinned.filter(x => x.id !== p.id)); }}
                                    className="px-2 py-1.5 text-slate-300 hover:text-rose-500 transition-colors"
                                    >
                                    <X size={12} />
                                    </button>
                                </div>
                                ))
                            )}
                            </div>
                        </div>

                        {/* Text Editor */}
                        <div className="flex-1 p-5 pt-0 flex flex-col relative">
                            <div className="flex-1 relative rounded-2xl border border-violet-100 dark:border-white/5 bg-white/50 dark:bg-[#0f0e15] overflow-hidden focus-within:ring-2 focus-within:ring-violet-500/30 transition-shadow shadow-inner mt-2">
                            <textarea
                                ref={textareaRef}
                                value={editorContent}
                                onChange={(e) => setEditorContent(e.target.value)}
                                placeholder="Start writing..."
                                className="w-full h-full p-6 bg-transparent resize-none outline-none font-serif text-lg leading-loose text-slate-800 dark:text-slate-200 placeholder:text-slate-300 dark:placeholder:text-slate-700"
                            />
                            
                            {/* Editor Toolbar */}
                            <div className="absolute bottom-4 right-4 flex gap-2">
                                <button 
                                onClick={clearCanvas}
                                className="p-2 text-slate-300 hover:text-rose-500 hover:bg-rose-50 dark:hover:bg-rose-900/20 rounded-lg transition-colors" 
                                title="Clear Editor"
                                >
                                <Trash2 size={16} />
                                </button>
                                <button 
                                onClick={() => {
                                    const blob = new Blob([editorContent], { type: 'text/markdown' });
                                    const url = URL.createObjectURL(blob);
                                    const a = document.createElement('a');
                                    a.href = url;
                                    a.download = 'synax-idea.md';
                                    a.click();
                                }}
                                className="p-2 text-slate-300 hover:text-violet-600 hover:bg-violet-50 dark:hover:bg-violet-900/20 rounded-lg transition-colors"
                                title="Download Markdown"
                                >
                                <Download size={16} />
                                </button>
                            </div>
                            </div>
                        </div>
                        </aside>
                    )}
                </div>

                {/* --- SETTINGS MODAL --- */}
                {showSettings && (
                    <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/60 backdrop-blur-md p-4 animate-in fade-in duration-200">
                        <div className="bg-white dark:bg-[#16151f] rounded-2xl w-full max-w-sm p-6 shadow-2xl shadow-violet-900/20 border border-white/20 dark:border-white/10 space-y-6">
                            <div className="flex justify-between items-center">
                                <h3 className="text-xl font-black text-slate-800 dark:text-white font-serif">Settings</h3>
                                <button onClick={() => setShowSettings(false)}><X className="text-slate-400 hover:text-slate-800 dark:hover:text-white transition-colors"/></button>
                            </div>
                            
                            <div className="space-y-3">
                                
                                {/* Dark Mode */}
                                <div className="flex items-center justify-between p-3 rounded-xl bg-slate-50 dark:bg-white/5">
                                    <div className="flex items-center gap-3">
                                        <div className={`p-2 rounded-lg ${darkMode ? 'bg-violet-600 text-white shadow-lg shadow-violet-600/30' : 'bg-white text-slate-400 shadow-sm'}`}>
                                            <Sparkles size={18} />
                                        </div>
                                        <span className="font-bold text-sm dark:text-slate-200">Dark Mode</span>
                                    </div>
                                    <button 
                                        onClick={() => setDarkMode(!darkMode)}
                                        className={`w-12 h-6 rounded-full transition-colors relative ${darkMode ? 'bg-violet-600' : 'bg-slate-300'}`}
                                    >
                                        <div className={`absolute top-1 left-1 bg-white w-4 h-4 rounded-full transition-transform ${darkMode ? 'translate-x-6' : ''}`} />
                                    </button>
                                </div>

                                {/* Minimal Mode */}
                                <div className="flex items-center justify-between p-3 rounded-xl bg-slate-50 dark:bg-white/5">
                                    <div className="flex items-center gap-3">
                                        <div className={`p-2 rounded-lg ${minimalMode ? 'bg-slate-700 text-white shadow-lg' : 'bg-white text-slate-400 shadow-sm'}`}>
                                            <Layout size={18} />
                                        </div>
                                        <div className="flex flex-col">
                                            <span className="font-bold text-sm dark:text-slate-200">Minimal Mode</span>
                                            <span className="text-[10px] text-slate-400">Zen layout, no distractions</span>
                                        </div>
                                    </div>
                                    <button 
                                        onClick={() => setMinimalMode(!minimalMode)}
                                        className={`w-12 h-6 rounded-full transition-colors relative ${minimalMode ? 'bg-slate-700' : 'bg-slate-300'}`}
                                    >
                                        <div className={`absolute top-1 left-1 bg-white w-4 h-4 rounded-full transition-transform ${minimalMode ? 'translate-x-6' : ''}`} />
                                    </button>
                                </div>

                                {/* Offline Mode */}
                                <div className="flex items-center justify-between p-3 rounded-xl bg-slate-50 dark:bg-white/5">
                                    <div className="flex items-center gap-3">
                                        <div className={`p-2 rounded-lg ${offlineMode ? 'bg-rose-500 text-white shadow-lg shadow-rose-500/30' : 'bg-white text-emerald-500 shadow-sm'}`}>
                                            {offlineMode ? <WifiOff size={18} /> : <Wifi size={18} />}
                                        </div>
                                        <div className="flex flex-col">
                                            <span className="font-bold text-sm dark:text-slate-200">Offline Mode</span>
                                        </div>
                                    </div>
                                    <button 
                                        onClick={() => setOfflineMode(!offlineMode)}
                                        className={`w-12 h-6 rounded-full transition-colors relative ${offlineMode ? 'bg-rose-500' : 'bg-emerald-400'}`}
                                    >
                                        <div className={`absolute top-1 left-1 bg-white w-4 h-4 rounded-full transition-transform ${offlineMode ? 'translate-x-6' : ''}`} />
                                    </button>
                                </div>

                                {/* Auto-Generate */}
                                <div className="p-3 rounded-xl bg-slate-50 dark:bg-white/5 space-y-3">
                                    <div className="flex items-center justify-between">
                                        <div className="flex items-center gap-3">
                                            <div className={`p-2 rounded-lg ${autoGen ? 'bg-amber-500 text-white shadow-lg shadow-amber-500/30' : 'bg-white text-slate-400 shadow-sm'}`}>
                                                <Timer size={18} />
                                            </div>
                                            <span className="font-bold text-sm dark:text-slate-200">Auto-Generate</span>
                                        </div>
                                        <button 
                                            onClick={() => setAutoGen(!autoGen)}
                                            className={`w-12 h-6 rounded-full transition-colors relative ${autoGen ? 'bg-amber-500' : 'bg-slate-300'}`}
                                        >
                                            <div className={`absolute top-1 left-1 bg-white w-4 h-4 rounded-full transition-transform ${autoGen ? 'translate-x-6' : ''}`} />
                                        </button>
                                    </div>
                                    
                                    {autoGen && (
                                        <div className="pt-2 animate-in fade-in slide-in-from-top-2">
                                            <div className="flex justify-between text-xs font-medium text-slate-500 mb-1">
                                            <span>Interval</span>
                                            <span>{autoGenInterval}s</span>
                                            </div>
                                            <input 
                                            type="range" 
                                            min="2" 
                                            max="30" 
                                            value={autoGenInterval} 
                                            onChange={(e) => setAutoGenInterval(parseInt(e.target.value))}
                                            className="w-full h-2 bg-slate-200 dark:bg-white/10 rounded-lg appearance-none cursor-pointer accent-amber-500"
                                            />
                                        </div>
                                    )}
                                </div>

                                <div className="pt-4 border-t border-slate-100 dark:border-white/5">
                                    <button onClick={clearHistory} className="w-full py-3 text-sm font-bold text-rose-500 hover:bg-rose-50 dark:hover:bg-rose-900/10 rounded-xl transition-colors">
                                        Clear Session History
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                )}

                {/* --- DEFINITION MODAL --- */}
                {definition && (
                    <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/60 backdrop-blur-md p-4 animate-in fade-in duration-200" onClick={() => setDefinition(null)}>
                    <div className="bg-white dark:bg-[#16151f] rounded-2xl max-w-lg w-full p-8 shadow-2xl border border-white/20 dark:border-white/10" onClick={e => e.stopPropagation()}>
                        <div className="flex justify-between items-start mb-6">
                            <div>
                                <h2 className="text-4xl font-serif font-black text-slate-900 dark:text-white capitalize tracking-tight mb-2">{definition.word}</h2>
                                {definition.phonetic && (
                                    <span className="text-violet-500 font-mono text-sm px-2 py-1 bg-violet-50 dark:bg-violet-900/20 rounded">{definition.phonetic}</span>
                                )}
                            </div>
                            <button onClick={() => setDefinition(null)} className="p-2 hover:bg-slate-100 dark:hover:bg-white/10 rounded-full text-slate-400 transition-colors"><X size={24}/></button>
                        </div>
                        
                        <div className="space-y-6 max-h-[60vh] overflow-y-auto custom-scrollbar">
                            {definition.meanings?.map((m, i) => (
                            <div key={i}>
                                <span className="text-xs font-bold uppercase text-slate-400 tracking-widest">{m.partOfSpeech}</span>
                                <ul className="mt-3 space-y-3">
                                {m.definitions.slice(0, 2).map((d, j) => (
                                    <li key={j} className="text-slate-700 dark:text-slate-300 leading-relaxed pl-4 border-l-2 border-violet-200 dark:border-violet-800">
                                    {d.definition}
                                    </li>
                                ))}
                                </ul>
                            </div>
                            ))}
                            {definition.meanings?.length === 0 && (
                            <div className="text-center py-8">
                                <BookOpen size={40} className="mx-auto text-slate-200 mb-4"/>
                                <p className="text-slate-500 italic">No definition found. It might be a rare or poetic word.</p>
                            </div>
                            )}
                        </div>
                        
                        <div className="mt-8 flex justify-end pt-4 border-t border-slate-100 dark:border-white/5">
                            <a 
                            href={`https://www.google.com/search?q=define+${definition.word}`} 
                            target="_blank" 
                            rel="noreferrer"
                            className="text-sm font-bold text-violet-600 hover:text-violet-500 flex items-center gap-1 group"
                            >
                            Full details <ChevronRight size={14} className="group-hover:translate-x-1 transition-transform" />
                            </a>
                        </div>
                    </div>
                    </div>
                )}
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<Synax />);
    </script>
</body>
</html>